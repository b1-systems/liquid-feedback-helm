# Default values for liquid-feedback.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# number of frontend processes
replicaCount: 1

image:
  repository: "poelzi/liquid-feedback-k8s"
  pullPolicy: IfNotPresent
  # pullPolicy: Always
  # Overrides the image tag whose default is the chart appVersion.
  tag: "0.8.0"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext:
  runAsUser: 33
  runAsGroup: 33
  fsGroup: 33
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

adminUsers:
  - name: admin
    password: liquid


# liquid feedback frontend settings
# 
frontend:
  absoluteBaseUrl: "http://localhost:8080"
  name: "Unnamed LiquidFeedback"
  # will be set to ingress address if ingress is enabled
  # absoluteBaseUrl: "http://localhost:8080"
  # none|anonymous|authors_pseudonymous|all_pseudonymous|everything
  # enable debug tracing
  debug: false
  publicAccess: "none"
  useTerms: "<h1>Terms of Use</h1><p>Have fun</p>"
  # these are discount -f flags
  markdownAllow: "links,fencedcode"
  markdownRemoveImages: true
  enabledLanguages:
    - "en"
    - "el"
    - "de"
    - "eo"
    - "it"
    - "nl"
    - "zh-Hans"
    - "zh-TW"
  defaultLanguage: "en"
  disableRegistrations: false
  # motdPublic: "<h1>Message of the day (public)</h1>"
  # motdIntern: "<h1>Message of the day (public)</h1>"
  # etherpad:
      # base_url = "http://example.com:9001/",
      # api_base = "http://localhost:9001/",
      # api_key = "mysecretapikey",
      # group_id = "mygroupname",
      # cookie_path = "/"
  # listen to ipv6 connections
  ipv6: false
  # fork:
  #   min: 3
  #   max: 128
  # httpOptions:
  #   static_headers:
  #     - "Strict-Transport-Security: max-age=3153600"
  #   idle_timeout: 85
  delegation:
    warningTime: "6 months"
    intervalHard: "6 months"
    intervalSoft: "3 months"
    default: "confirm"
  
  profile:
    fields: [] # extra fields for users

  etherpad:
    enabled: false
    # external url
    url: "http://etherpad.example.com"
    # api url
    apiUrl: "http://localhost:9001/"
    apiKey: "mysecretapikey"
    groupId: "mygroupname"
    cookiePath: "/"

  # this is still work in progress
  oauth:
    enabled: false
    endpointMagic: "liquidfeedback_client_redirection_endpoint"
    authorizationCodeLifetime: 300
    dynamicRegistrationLifetime: 300
    # providers:
    #   myoauth:
    #     # must start with 'dynamic:[hostname]'
    #     clientId: "dynamic:auth.example.com"
    #     # clientSecret: "liquidfeedback_client_secret"
    #     # redirectUri: "http://localhost:8080/oauth/callback"
    #     scope: "email"
    #     # must be either code ore token
    #     flow: "token"

mail:
  subjectPrefix: "[LiquidFeedback] "
  envelopFrom: "liquidfeedback@example.com"
  from:
    name: "Support"
    email: "support@example.com"
  replyTo:
    name: "Support"
    email: "support@example.com"



# you can define arbitrary lua code that will be appended
# to the generated config. Since this code runs after the
# autogenerated config, you can override everything
frontendExtra: |
  --[[
  config.free_timing = {
  calculate_func = function(policy, timing_string)
      local function interval_by_seconds(secs)
      local secs_per_day = 60 * 60 * 24
      local days
      days = math.floor(secs / secs_per_day)
      secs = secs - days * secs_per_day
      return days .. " days " .. secs .. " seconds"
      end
      local target_date = parse.date(timing_string, atom.date)
      if not target_date then
      return false
      end
      local target_timestamp = target_date.midday
      local now = atom.timestamp:get_current()
      trace.debug(target_timestamp, now)
      local duration = target_timestamp - now
      if duration < 0 then
      return false
      end
      return {
      discussion = interval_by_seconds(duration / 7 * 4),
      verification = interval_by_seconds(duration / 7 * 1),
      voting = interval_by_seconds(duration / 7 * 2)
      }
  end,
  available_func = function(policy)
      return {
      { name = "End of 2013", id = '2013-12-31' },
      { name = "End of 2014", id = '2014-12-31' },
      { name = "End of 2015", id = '2015-12-31' }
      }
  end
  }
  --]]

ldap:
  enabled: false
  password: "Not@SecurePassw0rd"
  # the config can be quite complex and needs to be done by hand
  # the secret can be read from a file in /etc/lf-password-ldap/ldap
  config: |
    config.ldap = {
      hosts = {
        { uri = "ldap://ldap.default.svc.cluster.local", tls = false, timeout = 5 },
      },
      base = "dc=example,dc=org",
      bind_as = { dn = "cn=admin,dc=example,dc=org", password = readAll("/etc/lf-password-ldap/ldap") },
      member = {
        registration = "auto",
        scope = "subtree",
        login_normalizer = function (login)
          return login:lower()
        end,
        login_filter_map = function (login)
          return "(uid=" .. ldap.escape_filter(login) .. ")"
        end,
        login_map = function (ldap_entry)
          return ldap_entry.uid[1]
        end,
        uid_filter_map = function (uid)
          return "(uidNumber=" .. ldap.escape_filter(uid) .. ")"
        end,
        uid_map = function (ldap_entry)
        print("mapping:", ldap_entry.uidNumber[1], ldap_entry.uid)
          return ldap_entry.uidNumber[1]
        end,
        allowed_map = function (ldap_entry)
          return true
        end,
        fetch_attr = { "uid", "cn", "uidNumber", "givenName", "sn", "displayName", "memberof" },
        attr_map = function (ldap_entry, member)
          if ldap_entry.givenName then
            member.identification = ldap_entry.givenName[1] .. " " .. ldap_entry.sn[1]
          else
            member.identification = ldap_entry.cn[1] .. " " .. ldap_entry.sn[1]
          end
          if ldap_entry.displayName then
            member.name = ldap_entry.displayName[1]
          else
            member.name = ldap_entry.cn[1]
          end
        end,
        privilege_map = function (ldap_entry, member)
          local privileges
          -- it is important that the unit id exists, otherwise
          -- login will fail
          if ldap_entry.dn:match("ou=users,dc=example,dc=org") then
            privileges = {
              { unit_id = 4, voting_right = true, polling_right = true },
              -- { unit_id = 2, voting_right = true, polling_right = false },
              -- { unit_id = 3, voting_right = false, polling_right = true }
            }
          elseif ldap_entry.dn:match("ou=employees,dc=example,dc=org$") then
            privileges = {
              { unit_id = 1, voting_right = false, polling_right = true },
              { unit_id = 2, voting_right = false, polling_right = true },
              { unit_id = 3, voting_right = true, polling_right = false }
            }
          elseif ldap_entry.dn:match("ou=member,dc=example,dc=org$") then
            privileges = {
              { unit_id = 1, voting_right = true, polling_right = false }
            }
          end
          return privileges
        end,
        cache_passwords = true,
        locked_profile_fields = { name = true }
      }
    }

# example AD configuration

# ldap:
#   enabled: true
#   password: "Not@SecurePassw0rd"
#   # the config can be quite complex and needs to be done by hand
#   # the secret can be read from a file in /etc/lf-password-ldap/ldap
#   config: |
#     local function str2hex(s)
#       local t = {string.byte(s, 1, #s)}
#       local f = string.format
#       for i = 1, #t do t[i] = f("\\%02x", t[i]) end
#       return table.concat(t)
#     end

#     config.ldap = {
#       hosts = { 
#         { uri = "ldap://192.168.1.1", tls = true, timeout = 5 },
#         { uri = "ldap://192.168.1.2", tls = true, timeout = 5 }
#       },
#       base = "CN=Users,DC=example,DC=org",
#       bind_as = { dn = "CN=LiquidFeedback Service,CN=Users,DC=example,DC=org", password = "secure" },
#       member = {
#         registration = "auto",
#         scope = "subtree",
#         login_normalizer = function (login)
#           return login:lower()
#         end,
#         login_filter_map = function (login)
#           return "(sAMAccountName=" .. ldap.escape_filter(login) .. ")"
#         end,
#         login_map = function (ldap_entry)
#           return ldap_entry.sAMAccountName[1]
#         end,
#         uid_filter_map = function (uid)
#           return "(objectGUID=" .. uid .. ")"
#         end,
#         uid_map = function (ldap_entry)
#           return str2hex(ldap_entry.objectGUID[1])
#         end,
#         allowed_map = function (ldap_entry)
#           local allowed = false
#           if ldap_entry.memberOf then
#             for i, group in ipairs(ldap_entry.memberOf) do
#               if group == "CN=LiquidFeedback User,CN=Users,DC=example,DC=org" then
#                 allowed = true
#               end
#             end
#           end
#           return allowed
#         end,
#         fetch_attr = { "sAMAccountName", "objectGUID", "givenName", "name", "displayName", "memberOf" },
#         attr_map = function (ldap_entry, member)
#           member.identification = ldap_entry.givenName[1] .. " " .. ldap_entry.name[1]
#           member.name = ldap_entry.displayName[1]
#         end,
#         privilege_map = function (ldap_entry, member)
#           local privileges = {}
#           if ldap_entry.memberOf then
#             for i, group in ipairs(ldap_entry.memberOf) do
#               if group == "CN=LiquidFeedback User,CN=Users,DC=example,DC=org" then
#                 table.insert(privileges,
#                   { unit_id = 1, voting_right = true, polling_right = true }
#                 )
#               end
#             end
#           end
#           return privileges
#         end,
#         cache_passwords = true,
#         locked_profile_fields = { name = true }
#       }
#     }



# use zalando postgresql operator
pgoperator:
  enabled: true
  instances: 1
  version: "15"
  size: 1G
  teamId: "default"
  # storageClass: "ssd"
  resources:
    requests:
      cpu: 300m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 128Mi

# use crunchdata postgresql operator
pgcluster:
  enabled: false
  name: liquid-feedback-db
  user: liquid_feedback
  password: liquid_feedback
  database: liquid_feedback
  backup_size: 5G
  size: 1G

postgresql:
  username: liquidfeedback
  database: liquid_feedback
  # hostname to use if not using postgresql operator
  # hostname: mydatabase
  # secretName: mysecret
  # secretKey: password

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# ensure that frontend.fork makes sense for your autoscaling settings

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}
